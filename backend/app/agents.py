from typing import Dict, Any, List
import httpx
import json

OLLAMA_BASE_URL = "http://localhost:11434"
OLLAMA_GENERATOR_MODEL = "codellama:34b"  # For code generation and formal definitions
OLLAMA_EXPLAINER_MODEL = "deepseek-coder:33b"  # For explanations and educational reasoning

class AutomataGenerator:
    """Uses codellama:34b for formal automata generation and code"""
    
    async def generate_automaton(self, task: str, problem_type: str = "dfa") -> Dict[str, Any]:
        """Generate formal automaton structure and implementation code"""
        prompt = f"""
You are an expert in Theory of Computation and formal automata. Generate a complete {problem_type.upper()} for this task:

Task: {task}

Please provide a structured response with:

1. FORMAL DEFINITION:
   - States (Q)
   - Alphabet (Σ)
   - Transition function (δ)
   - Start state (q₀)
   - Accept states (F)

2. PYTHON IMPLEMENTATION:
   - Complete simulation function
   - State transition logic
   - String acceptance testing

3. DOT GRAPH CODE:
   - Graphviz DOT notation for visualization
   - Proper state and transition labeling

4. TEST CASES:
   - 5 strings that should be accepted
   - 5 strings that should be rejected

Format your response as JSON with keys: formal_definition, python_code, dot_graph, test_cases
"""

        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{OLLAMA_BASE_URL}/api/generate",
                    json={
                        "model": OLLAMA_GENERATOR_MODEL,
                        "prompt": prompt,
                        "stream": False
                    },
                    timeout=60.0
                )
                
                if response.status_code == 200:
                    result = response.json()
                    ai_response = result.get("response", "")
                    
                    try:
                        return json.loads(ai_response)
                    except json.JSONDecodeError:
                        return {
                            "formal_definition": "Generated by AI",
                            "python_code": ai_response,
                            "dot_graph": "// Generated DOT code",
                            "test_cases": {"accept": [], "reject": []}
                        }
                else:
                    return self._fallback_response(task, problem_type)
                    
        except Exception as e:
            return self._fallback_response(task, problem_type)
    
    def _fallback_response(self, task: str, problem_type: str) -> Dict[str, Any]:
        """Fallback response when AI is unavailable"""
        return {
            "formal_definition": f"Please manually design a {problem_type.upper()} for: {task}",
            "python_code": "# AI code generation temporarily unavailable",
            "dot_graph": "// DOT graph generation temporarily unavailable",
            "test_cases": {"accept": ["example1"], "reject": ["example2"]}
        }

class AutomataExplainer:
    """Uses deepseek-coder:33b for educational explanations and step-by-step reasoning"""
    
    async def explain_automaton(self, task: str, automaton_data: Dict[str, Any], user_automaton: Any = None) -> Dict[str, Any]:
        """Provide detailed educational explanation of the automaton"""
        prompt = f"""
You are an expert Theory of Computation tutor. A student is learning about automata and needs a clear, educational explanation.

Task: {task}

Generated Automaton:
{json.dumps(automaton_data, indent=2)}

Please provide a comprehensive educational explanation including:

1. CONCEPTUAL OVERVIEW:
   - What this automaton does in simple terms
   - Why this design works for the given language

2. STATE-BY-STATE EXPLANATION:
   - Purpose of each state
   - What each state "remembers" or tracks

3. TRANSITION LOGIC:
   - Why each transition exists
   - How symbols affect state changes

4. EXAMPLE WALKTHROUGH:
   - Step-by-step execution on an accepting string
   - Step-by-step execution on a rejecting string

5. COMMON MISTAKES:
   - What students often get wrong
   - How to avoid these pitfalls

6. LEARNING INSIGHTS:
   - Key automata theory concepts demonstrated
   - Connections to other CS concepts

Be encouraging, clear, and pedagogically sound. Use analogies where helpful.
"""

        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{OLLAMA_BASE_URL}/api/generate",
                    json={
                        "model": OLLAMA_EXPLAINER_MODEL,
                        "prompt": prompt,
                        "stream": False
                    },
                    timeout=45.0
                )
                
                if response.status_code == 200:
                    result = response.json()
                    explanation = result.get("response", "")
                    
                    return {
                        "explanation": explanation,
                        "key_concepts": self._extract_concepts(explanation),
                        "next_steps": self._suggest_next_steps(task)
                    }
                else:
                    return self._fallback_explanation(task)
                    
        except Exception as e:
            return self._fallback_explanation(task)
    
    async def provide_step_guidance(self, task: str, current_progress: Dict[str, Any]) -> str:
        """Provide real-time step-by-step guidance as student builds automaton"""
        prompt = f"""
You are a Theory of Computation professor providing real-time guidance to a student.

Task: {task}

Student's Current Progress:
- States: {current_progress.get('states', 0)}
- Transitions: {current_progress.get('transitions', 0)}
- Start States: {current_progress.get('start_states', 0)}
- Accept States: {current_progress.get('accept_states', 0)}

Provide ONE specific, actionable next step. Be encouraging and educational.
Focus on what they should do next, not the complete solution.
"""

        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{OLLAMA_BASE_URL}/api/generate",
                    json={
                        "model": OLLAMA_EXPLAINER_MODEL,
                        "prompt": prompt,
                        "stream": False
                    },
                    timeout=15.0
                )
                
                if response.status_code == 200:
                    result = response.json()
                    return result.get("response", "Consider what states you need to track the problem requirements.")
                else:
                    return "Consider what states you need to track the problem requirements."
                    
        except Exception as e:
            return "Consider what states you need to track the problem requirements."
    
    def _extract_concepts(self, explanation: str) -> List[str]:
        """Extract key learning concepts from explanation"""
        concepts = []
        lines = explanation.lower().split('\n')
        
        concept_keywords = ['state', 'transition', 'language', 'alphabet', 'deterministic', 'nondeterministic']
        for line in lines:
            for keyword in concept_keywords:
                if keyword in line and len(line.strip()) < 100:
                    concepts.append(line.strip())
                    break
        
        return concepts[:5]  # Return top 5 concepts
    
    def _suggest_next_steps(self, task: str) -> List[str]:
        """Suggest next learning steps"""
        return [
            "Try building this automaton step by step",
            "Test your automaton with the provided examples",
            "Consider variations of this problem",
            "Explore related automata theory concepts"
        ]
    
    def _fallback_explanation(self, task: str) -> Dict[str, Any]:
        """Fallback explanation when AI is unavailable"""
        return {
            "explanation": f"This automaton solves the problem: {task}. Consider the states needed to track progress toward accepting valid strings.",
            "key_concepts": ["states", "transitions", "acceptance"],
            "next_steps": ["Build the automaton step by step", "Test with examples"]
        }
